#![feature(array_map)]
//! A WebAssembly test case generator.
//!
//! ## Usage
//!
//! First, use [`cargo fuzz`](https://github.com/rust-fuzz/cargo-fuzz) to define
//! a new fuzz target:
//!
//! ```shell
//! $ cargo fuzz add my_wasm_smith_fuzz_target
//! ```
//!
//! Next, add `wasm-smith` to your dependencies:
//!
//! ```toml
//! # fuzz/Cargo.toml
//!
//! [dependencies]
//! wasm-smith = "0.1.5"
//! ```
//!
//! Then, define your fuzz target so that it takes arbitrary
//! `wasm_smith::Module`s as an argument, convert the module into serialized
//! Wasm bytes via the `to_bytes` method, and then feed it into your system:
//!
//! ```no_run
//! // fuzz/fuzz_targets/my_wasm_smith_fuzz_target.rs
//!
//! #![no_main]
//!
//! use libfuzzer_sys::fuzz_target;
//! use wasm_smith::Module;
//!
//! fuzz_target!(|module: Module| {
//!     let wasm_bytes = module.to_bytes();
//!
//!     // Your code here...
//! });
//! ```
//!
//! Finally, start fuzzing:
//!
//! ```shell
//! $ cargo fuzz run my_wasm_smith_fuzz_target
//! ```
//!
//! > **Note:** For a real world example, also check out [the `validate` fuzz
//! > target](https://github.com/fitzgen/wasm-smith/blob/main/fuzz/fuzz_targets/validate.rs)
//! > defined in this repository. Using the `wasmparser` crate, it checks that
//! > every module generated by `wasm-smith` validates successfully.

#![deny(missing_docs, missing_debug_implementations)]
// Needed for the `instructions!` macro in `src/code_builder.rs`.
#![recursion_limit = "256"]

use std::{
    collections::{HashMap, HashSet},
    rc::Rc,
    str,
};

use arbitrary::{Arbitrary, Result, Unstructured};

pub use config::{Config, DefaultConfig, InterpreterConfig};
use ValType::{I32, I64};

use crate::{code_builder::CodeBuilderAllocations, config::HostFunction};
use std::{
    cmp::{max, min},
    sync::atomic::{AtomicU8, Ordering},
};

mod code_builder;
mod config;
mod encode;
mod terminate;

/// A pseudo-random WebAssembly module.
///
/// Construct instances of this type with [the `Arbitrary`
/// trait](https://docs.rs/arbitrary/*/arbitrary/trait.Arbitrary.html).
///
/// ## Configuring Generated Modules
///
/// This uses the [`DefaultConfig`][crate::DefaultConfig] configuration. If you
/// want to customize the shape of generated modules, define your own
/// configuration type, implement the [`Config`][crate::Config] trait for it,
/// and use [`ConfiguredModule<YourConfigType>`][crate::ConfiguredModule]
/// instead of plain `Module`.
#[derive(Debug, Default, Arbitrary)]
pub struct Module {
    inner: ConfiguredModule<DefaultConfig>,
}

const PAGE_SIZE: u32 = 65536;

/// A pseudo-random generated WebAssembly file with custom configuration.
///
/// If you don't care about custom configuration, use [`Module`][crate::Module]
/// instead.
///
/// For details on configuring, see the [`Config`][crate::Config] trait.
#[derive(Debug, Default)]
pub struct ConfiguredModule<C>
where
    C: Config, {
    config:   C,
    valtypes: Vec<ValType>,

    /// The initial sections of this wasm module, including types and imports.
    /// This is stored as a list-of-lists where each `InitialSection` represents
    /// a whole section, so this `initial_sections` list represents a list of
    /// sections.
    ///
    /// With the module linking proposal, types, imports, module, instance,
    /// and alias sections can come in any order and occur repeatedly at the
    /// start of a Wasm module. We want to generate interesting entities --
    /// entities that require multiple, interspersed occurrences of these
    /// sections -- and we don't want to always generate the "same shape" of
    /// these initial sections. Each entry in this initializers list is one of
    /// these initial sections, and we will directly encode each entry as a
    /// section when we serialize this module to bytes, which allows us to
    /// easily model the flexibility of the module linking proposal.
    initial_sections: Vec<InitialSection>,

    /// A map of what import names have been generated. The key here is the
    /// name of the import and the value is `None` if it's a single-level
    /// import or `Some` if it's a two-level import with the set of
    /// second-level import names that have been generated so far.
    import_names: HashMap<String, Option<HashSet<String>>>,

    /// Where within the `instances` array each implicit instance's type is
    /// defined.
    implicit_instance_types: HashMap<String, usize>,

    /// Keeping track of used host functions (because we disallow repeating
    /// imports)
    used_imports: HashSet<usize>,

    /// All types locally defined in this module (available in the type index
    /// space).
    types: Vec<Defined>,
    /// Indices within `types` that are (non-host) function types.
    func_types: Vec<usize>,
    /// Indices within `types` that are host-function types.
    host_func_types: Vec<usize>,

    /// Number of imported items into this module.
    num_imports: usize, /* todo (MRA) remove this and only use imported funcs because we only
                         * allow importing functions */
    /// Names of already imported host functions
    imported_funcs: Vec<String>,
    /// Indices within `types` that can be types of functions that can be
    /// exported
    valid_export_types: Vec<usize>,
    /// Indices within `types` that are used for the auxiliary export functions
    auxiliary_export_types: Vec<usize>,
    /// Indices within `funcs` that are auxiliary functions,
    /// along with the index to the function they call (index in `funcs`, and
    /// the required return type (index in `types`) TODO (MRA) This is all
    /// horrible. Encode this stuff in the type system.
    auxiliary_funcs: Vec<(usize, usize, usize)>,

    /// The number of functions defined in this module (not imported or
    /// aliased).
    num_defined_funcs: usize,

    /// The number of tables defined in this module (not imported or
    /// aliased).
    num_defined_tables: usize,

    size_of_biggest_table: u32,

    /// The number of memories defined in this module (not imported or
    /// aliased).
    num_defined_memories: usize,

    size_of_biggest_memory: u32,

    /// The indexes and initialization expressions of globals defined in this
    /// module.
    defined_globals: Vec<(u32, Instruction)>,

    /// All functions available to this module, sorted by their index. The list
    /// entry points to the index in this module where the function type is
    /// defined (if available) and provides the type of the function.
    ///
    /// Note that aliased functions may have types not defined in this module,
    /// hence the optional index type. All defined functions in this module,
    /// however, will have an index type specified.
    funcs: Vec<(usize, Rc<FuncType>)>,

    /// All tables available to this module, sorted by their index. The list
    /// entry is the type of each table.
    tables: Vec<TableType>,

    /// All globals available to this module, sorted by their index. The list
    /// entry is the type of each global.
    globals: Vec<GlobalType>,

    /// All memories available to this module, sorted by their index. The list
    /// entry is the type of each memory.
    memories: Vec<MemoryType>,

    exports: Vec<(String, Export)>,
    start:   Option<u32>,
    elems:   Vec<ElementSegment>,
    code:    Vec<Code>,
    data:    Vec<DataSegment>,
}

impl<C: Config> ConfiguredModule<C> {
    /// Returns a reference to the internal configuration.
    pub fn config(&self) -> &C { &self.config }
}

impl<C: Config> Arbitrary for ConfiguredModule<C> {
    fn arbitrary(u: &mut Unstructured) -> Result<Self> {
        let mut module = ConfiguredModule::<C>::default();
        module.build(u, false)?;
        Ok(module)
    }
}

/// Same as [`Module`], but may be invalid.
///
/// This module generates function bodies differently than `Module` to try to
/// better explore wasm decoders and such.
#[derive(Debug, Default)]
pub struct MaybeInvalidModule {
    module: Module,
}

impl MaybeInvalidModule {
    /// Encode this Wasm module into bytes.
    pub fn to_bytes(&self) -> Vec<u8> { self.module.to_bytes() }
}

impl Arbitrary for MaybeInvalidModule {
    fn arbitrary(u: &mut Unstructured) -> Result<Self> {
        let mut module = Module::default();
        module.inner.build(u, module.inner.config.allow_arbitrary_instr())?;
        Ok(MaybeInvalidModule {
            module,
        })
    }
}

#[derive(Debug)]
enum InitialSection {
    Type(Vec<Rc<FuncType>>),
    Import(Vec<(String, Option<String>, FunctionType)>),
}

/// Representation of a function type
#[derive(Clone, Debug, PartialEq, Eq, Hash)]
struct FuncType {
    params:        Vec<ValType>,
    result:        Option<ValType>,
    host_function: Option<HostFunction>,
    auxiliary:     bool,
}

#[derive(Clone, Debug)]
enum FunctionType {
    Func(usize, Rc<FuncType>),
}

/// Types of Wasm values
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub enum ValType {
    /// 32-bit integer type
    I32,
    /// 64-bit integer type
    I64,
    /// Function reference type
    FuncRef,
    /// `externref` type
    ExternRef,
}

#[derive(Clone, Debug)]
struct TableType {
    limits:  Limits,
    elem_ty: ValType,
}

#[derive(Clone, Debug)]
struct MemoryType {
    limits: Limits,
}

#[derive(Clone, Debug)]
struct Limits {
    min: u32,
    max: Option<u32>,
}

impl Limits {
    fn limited(u: &mut Unstructured, max_minimum: u32, max_required: bool) -> Result<Self> {
        let min = u.int_in_range(0..=max_minimum)?;
        let max = if max_required || u.arbitrary().unwrap_or(false) {
            Some(
                if min == max_minimum {
                    max_minimum
                } else {
                    u.int_in_range(min..=max_minimum)?
                },
            )
        } else {
            None
        };
        Ok(Limits {
            min,
            max,
        })
    }
}

#[derive(Clone, Debug, PartialEq)]
struct GlobalType {
    val_type: ValType,
    mutable:  bool,
}

#[derive(Copy, Clone, Debug)]
enum Export {
    Func(u32), // the index in `funcs`
    Table(u32),
    Memory(u32),
    Global(u32),
}

#[derive(Debug)]
struct ElementSegment {
    kind:  ElementKind,
    ty:    ValType,
    items: Elements,
}

#[derive(Debug)]
enum ElementKind {
    // TODO (MRA) get rid of single enum
    Active {
        table:  Option<u32>, // None == table 0 implicitly
        offset: Instruction,
    },
}

#[derive(Debug)]
enum Elements {
    Functions(Vec<u32>),
    Expressions(Vec<Option<u32>>),
}

#[derive(Debug)]
struct Code {
    locals:       Vec<ValType>,
    instructions: Instructions,
}

#[derive(Debug)]
enum Instructions {
    Generated(Vec<Instruction>),
    Arbitrary(Vec<u8>),
}

#[derive(Clone, Copy, Debug)]
enum BlockType {
    Empty,
    Result(ValType),
    FuncType(usize),
}

impl BlockType {
    fn params_results<C>(&self, module: &ConfiguredModule<C>) -> (Vec<ValType>, Vec<ValType>)
    where
        C: Config, {
        match self {
            BlockType::Empty => (vec![], vec![]),
            BlockType::Result(t) => (vec![], vec![*t]),
            BlockType::FuncType(ty) => {
                let ty = module.func_type(*ty);
                (ty.params.clone(), ty.result.into_iter().collect())
            }
        }
    }
}

#[derive(Clone, Copy, Debug)]
struct MemArg {
    offset:       u32,
    align:        u32,
    memory_index: u32,
}

#[derive(Clone, Debug)]
#[allow(non_camel_case_types)]
enum Instruction {
    // Control instructions.
    Unreachable,
    Nop,
    Block(BlockType),
    Loop(BlockType),
    If(BlockType),
    Else,
    End,
    Br(u32),
    BrIf(u32),
    BrTable(Vec<u32>, u32),
    Return,
    Call(u32),
    CallIndirect {
        ty:    u32,
        table: u32,
    },

    // Parametric instructions.
    Drop,
    Select,

    // Variable instructions.
    LocalGet(u32),
    LocalSet(u32),
    LocalTee(u32),
    GlobalGet(u32),
    GlobalSet(u32),

    // Memory instructions.
    I32Load(MemArg),
    I64Load(MemArg),
    I32Load8_S(MemArg),
    I32Load8_U(MemArg),
    I32Load16_S(MemArg),
    I32Load16_U(MemArg),
    I64Load8_S(MemArg),
    I64Load8_U(MemArg),
    I64Load16_S(MemArg),
    I64Load16_U(MemArg),
    I64Load32_S(MemArg),
    I64Load32_U(MemArg),
    I32Store(MemArg),
    I64Store(MemArg),
    I32Store8(MemArg),
    I32Store16(MemArg),
    I64Store8(MemArg),
    I64Store16(MemArg),
    I64Store32(MemArg),
    MemorySize(u32),
    MemoryGrow(u32),

    // Numeric instructions.
    I32Const(i32),
    I64Const(i64),
    I32Eqz,
    I32Eq,
    I32Neq,
    I32LtS,
    I32LtU,
    I32GtS,
    I32GtU,
    I32LeS,
    I32LeU,
    I32GeS,
    I32GeU,
    I64Eqz,
    I64Eq,
    I64Neq,
    I64LtS,
    I64LtU,
    I64GtS,
    I64GtU,
    I64LeS,
    I64LeU,
    I64GeS,
    I64GeU,
    I32Clz,
    I32Ctz,
    I32Popcnt,
    I32Add,
    I32Sub,
    I32Mul,
    I32DivS,
    I32DivU,
    I32RemS,
    I32RemU,
    I32And,
    I32Or,
    I32Xor,
    I32Shl,
    I32ShrS,
    I32ShrU,
    I32Rotl,
    I32Rotr,
    I64Clz,
    I64Ctz,
    I64Popcnt,
    I64Add,
    I64Sub,
    I64Mul,
    I64DivS,
    I64DivU,
    I64RemS,
    I64RemU,
    I64And,
    I64Or,
    I64Xor,
    I64Shl,
    I64ShrS,
    I64ShrU,
    I64Rotl,
    I64Rotr,
    I32WrapI64,
    I64ExtendI32S,
    I64ExtendI32U,
    TypedSelect(ValType),
    RefNull(ValType),
    RefFunc(u32),
}

#[derive(Debug)]
struct DataSegment {
    kind: DataSegmentKind,
    init: Vec<u8>,
}

#[derive(Debug)]
enum DataSegmentKind {
    // TODO (MRA) convert to struct
    Active {
        memory_index: u32,
        offset:       Instruction,
    },
}

impl<C> ConfiguredModule<C>
where
    C: Config,
{
    fn validate_config(&self) {
        let config = &self.config;
        assert!(
            config.min_imports() <= config.min_funcs(),
            "The min number of imports cannot exceed min number of functions."
        );
    }

    fn build(&mut self, u: &mut Unstructured, allow_invalid: bool) -> Result<()> {
        self.config = C::arbitrary(u)?;
        self.validate_config();
        self.valtypes.push(ValType::I32);
        self.valtypes.push(ValType::I64);
        self.arbitrary_initial_sections(u)?;
        self.arbitrary_funcs(u)?;
        self.arbitrary_tables(u)?;
        self.arbitrary_memories(u)?;
        self.arbitrary_globals(u)?;
        self.arbitrary_exports(u)?;
        self.arbitrary_start(u)?;
        self.arbitrary_elems(u)?;
        self.arbitrary_data(u)?;
        self.arbitrary_code(u, allow_invalid)?;
        Ok(())
    }

    fn arbitrary_initial_sections(&mut self, u: &mut Unstructured) -> Result<()> {
        self.arbitrary_types(u)?;
        self.arbitrary_imports(u)?;
        Ok(())
    }

    fn arbitrary_types(&mut self, u: &mut Unstructured) -> Result<()> {
        // Note that we push to `self.initializers` immediately because types
        // can mention any previous types, so we need to ensure that after each
        // type is generated it's listed in the module's types so indexing will
        // succeed.
        let section_idx = self.initial_sections.len();
        self.initial_sections.push(InitialSection::Type(Vec::new()));
        // TODO (MRA) Here we first generate non-host-function types and then
        // host-function types. Intersperse them?
        arbitrary_loop(
            u,
            self.config.min_types(),
            self.config.max_types() - self.types.len(),
            |u| {
                let ty = self.arbitrary_func_type(u)?;
                self.add_type_to_initial_section(section_idx, ty);
                Ok(true)
            },
        )?;
        arbitrary_loop(u, self.config.min_imports(), self.config.max_imports(), |u| {
            let ty = self.arbitrary_hf_func_type(u)?;
            self.add_type_to_initial_section(section_idx, ty);
            Ok(true)
        })?;
        match self.config.allowed_export_types() {
            // If we restrict export types, we now make sure to add function calls
            // for all non-exportable functions so that they are reachable.
            Some(types) => {
                for (params, result) in types {
                    let ty = FuncType {
                        params,
                        result,
                        host_function: None,
                        auxiliary: true,
                    };
                    self.add_type_to_initial_section(section_idx, Rc::new(ty));
                }
            }
            None => (),
        }
        let types = match self.initial_sections.last_mut().unwrap() {
            InitialSection::Type(list) => list,
            _ => unreachable!(),
        };
        if types.is_empty() && !u.arbitrary()? {
            self.initial_sections.pop();
        }
        Ok(())
    }

    fn add_type_to_initial_section(&mut self, section_idx: usize, ty: Rc<FuncType>) {
        self.record_type(&ty);
        let types = match self.initial_sections.last_mut().unwrap() {
            InitialSection::Type(list) => list,
            _ => unreachable!(),
        };
        self.types.push(Defined {
            section: section_idx,
            nth:     types.len(),
        });
        types.push(ty);
    }

    fn record_type(&mut self, ty: &Rc<FuncType>) {
        let list = if ty.host_function.is_some() {
            &mut self.host_func_types
        } else {
            &mut self.func_types
        };
        let types_idx = self.types.len(); // TODO (MRA) This is very brittle. It relies on the fact that after record_type
                                          // is called we will add the type to `types`
        match self.config.allowed_export_types() {
            Some(types) => {
                if ty.host_function.is_none()
                    && types.contains(&(ty.params.clone(), ty.result.clone()))
                {
                    self.valid_export_types.push(types_idx);
                }
                if ty.auxiliary {
                    self.auxiliary_export_types.push(types_idx);
                }
            }
            _ => {
                // Return types are not restricted so add type
                self.valid_export_types.push(types_idx);
            }
        }
        list.push(types_idx);
    }

    fn arbitrary_func_type(&mut self, u: &mut Unstructured) -> Result<Rc<FuncType>> {
        let mut params = vec![];
        let mut result = None;
        arbitrary_loop(u, 0, self.config.max_parameters(), |u| {
            params.push(self.arbitrary_valtype(u)?);
            Ok(true)
        })?;
        if u.arbitrary()? {
            result = Some(self.arbitrary_valtype(u)?);
        }
        Ok(Rc::new(FuncType {
            params,
            result,
            host_function: None,
            auxiliary: false,
        }))
    }

    fn arbitrary_hf_func_type(&mut self, u: &mut Unstructured) -> Result<Rc<FuncType>> {
        assert!(!self.config().host_functions().is_empty(), "No host-function types specified");
        let hfs = self.config().host_functions();
        // generating index of an unused host function
        let hfs_len = hfs.len();
        let index = u.int_in_range(0..=hfs_len - 1)?;
        let mut unused_index = index;
        while self.used_imports.contains(&unused_index) {
            unused_index = (unused_index + 1) % hfs_len;
        }
        self.used_imports.insert(unused_index);
        let hf = &hfs[unused_index];
        let ret_type = hf.result;
        Ok(Rc::new(FuncType {
            params:        hf.params.clone(),
            result:        ret_type,
            host_function: Some(hf.clone()),
            auxiliary:     false,
        }))
    }

    fn can_add_local_func(&self) -> bool {
        self.func_types.len() > 0 && self.funcs.len() < self.config.max_funcs()
    }

    fn can_add_local_or_import_table(&self) -> bool { self.tables.len() < self.config.max_tables() }

    fn can_add_local_or_import_global(&self) -> bool {
        self.globals.len() < self.config.max_globals()
    }

    fn can_add_local_or_import_memory(&self) -> bool {
        self.memories.len() < self.config.max_memories()
    }

    fn arbitrary_imports(&mut self, u: &mut Unstructured) -> Result<()> {
        let mut imports = Vec::new();
        for idx in &self.host_func_types {
            let ty = self.func_type(*idx).clone();
            match &ty.host_function {
                Some(hf) => {
                    let hf_name = String::from(hf.name);
                    if !self.imported_funcs.contains(&hf_name) {
                        self.imported_funcs.push(hf_name);
                        self.funcs.push((*idx as usize, ty.clone()));
                        self.num_imports += 1;
                        imports.push((
                            String::from(hf.mod_name),
                            Some(String::from(hf.name)),
                            FunctionType::Func(*idx, ty),
                        ))
                    }
                }
                None => panic!("Only host functions can be imported"),
            }
        }
        if !imports.is_empty() || u.arbitrary()? {
            self.initial_sections.push(InitialSection::Import(imports));
        }

        // After an import section we can no longer update previously-defined
        // pseudo-instance imports, so set them all to `None` indicating that
        // the bare name is imported and finalized.
        for val in self.import_names.values_mut() {
            *val = None;
        }
        Ok(())
    }

    fn ty(&self, idx: usize) -> &Rc<FuncType> {
        match &self.types[idx as usize] {
            Defined {
                section,
                nth,
            } => {
                if let InitialSection::Type(list) = &self.initial_sections[*section] {
                    return &list[*nth];
                }
                panic!("looked up a type with the wrong index")
            }
        }
    }

    // All (non-host and host) function types
    fn func_types<'a>(&'a self) -> impl Iterator<Item = (usize, &'a FuncType)> + 'a {
        self.func_types
            .iter()
            .chain(&self.host_func_types)
            .copied()
            .map(move |type_i| (type_i, &**self.func_type(type_i)))
    }

    fn func_type(&self, idx: usize) -> &Rc<FuncType> { self.ty(idx) }

    fn funcs<'a>(&'a self) -> impl Iterator<Item = (u32, &'a Rc<FuncType>)> + 'a {
        self.funcs.iter().enumerate().map(move |(i, (_, ty))| (i as u32, ty))
    }

    fn arbitrary_valtype(&self, u: &mut Unstructured) -> Result<ValType> {
        Ok(*u.choose(&self.valtypes)?)
    }

    fn arbitrary_global_type(&self, u: &mut Unstructured) -> Result<GlobalType> {
        Ok(GlobalType {
            val_type: self.arbitrary_valtype(u)?,
            mutable:  u.arbitrary()?,
        })
    }

    fn arbitrary_table_type(&self, u: &mut Unstructured) -> Result<TableType> {
        Ok(TableType {
            elem_ty: ValType::FuncRef,
            limits:  Limits::limited(u, self.config.max_init_table_size(), false)?,
        })
    }

    fn arbitrary_funcs(&mut self, u: &mut Unstructured) -> Result<()> {
        if self.func_types.is_empty() {
            return Ok(());
        }

        arbitrary_loop(u, self.config.min_funcs(), self.config.max_funcs(), |u| {
            if !self.can_add_local_func() {
                return Ok(false);
            }

            let func_types = self.func_types.len();
            let export_types = self.auxiliary_export_types.len();
            // If all we created were export types, it means we don't have any types for
            // functions, so we won't create any functions.
            assert!(
                func_types > export_types,
                "We should have created at least one type for defined functions."
            );
            let max = func_types - export_types - 1;
            let ty = self.func_types[u.int_in_range(0..=max)?];
            self.funcs.push((ty, self.func_type(ty).clone()));
            self.num_defined_funcs += 1;
            Ok(true)
        })?;

        // Defining auxiliary functions
        let defined_fun_len = self.num_defined_funcs;
        for export_type in self.auxiliary_export_types.iter() {
            for i in self.funcs.len() - defined_fun_len..self.funcs.len() {
                self.funcs.push((*export_type, self.func_type(*export_type).clone()));
                self.auxiliary_funcs.push((self.funcs.len(), i, *export_type));
                self.num_defined_funcs += 1;
            }
        }
        Ok(())
    }

    fn arbitrary_tables(&mut self, u: &mut Unstructured) -> Result<()> {
        arbitrary_loop(
            u,
            self.config.min_tables() as usize,
            self.config.max_tables() as usize,
            |u| {
                if !self.can_add_local_or_import_table() {
                    return Ok(false);
                }
                self.num_defined_tables += 1;
                let ty = self.arbitrary_table_type(u)?;
                let biggest_table = ty.limits.min;
                self.size_of_biggest_table = max(self.size_of_biggest_table, biggest_table);
                self.tables.push(ty);
                Ok(true)
            },
        )
    }

    fn arbitrary_memtype(&self, u: &mut Unstructured) -> Result<MemoryType> {
        let limits = Limits::limited(
            u,
            self.config.max_memory_pages(),
            self.config.memory_max_size_required(),
        )?;
        Ok(MemoryType {
            limits,
        })
    }

    fn arbitrary_memories(&mut self, u: &mut Unstructured) -> Result<()> {
        arbitrary_loop(
            u,
            self.config.min_memories() as usize,
            self.config.max_memories() as usize,
            |u| {
                if !self.can_add_local_or_import_memory() {
                    return Ok(false);
                }
                self.num_defined_memories += 1;
                let memory_type = self.arbitrary_memtype(u)?;
                self.size_of_biggest_memory =
                    max(memory_type.limits.min, self.size_of_biggest_memory);
                self.memories.push(memory_type);
                Ok(true)
            },
        )
    }

    fn arbitrary_globals(&mut self, u: &mut Unstructured) -> Result<()> {
        arbitrary_loop(u, self.config.min_globals(), self.config.max_globals(), |u| {
            if !self.can_add_local_or_import_global() {
                return Ok(false);
            }

            let ty = self.arbitrary_global_type(u)?;

            let num_funcs = self.funcs.len() as u32;
            let expr = match ty.val_type {
                ValType::I32 => Instruction::I32Const(u.arbitrary()?),
                ValType::I64 => Instruction::I64Const(u.arbitrary()?),
                ValType::ExternRef => Instruction::RefNull(ValType::ExternRef),
                ValType::FuncRef => {
                    if num_funcs > 0 && u.arbitrary()? {
                        let func = u.int_in_range(0..=num_funcs - 1)?;
                        Instruction::RefFunc(func)
                    } else {
                        Instruction::RefNull(ValType::FuncRef)
                    }
                }
            };
            let global_idx = self.globals.len() as u32;
            self.globals.push(ty);
            self.defined_globals.push((global_idx, expr));
            Ok(true)
        })
    }

    fn arbitrary_exports(&mut self, u: &mut Unstructured) -> Result<()> {
        let mut choices: Vec<fn(&mut Unstructured, &mut ConfiguredModule<C>) -> Result<_>> =
            Vec::with_capacity(4);

        if self.funcs.len() > 0 && self.valid_export_types.len() > 0 {
            choices.push(|u, m| {
                // Filtering out the indices of functions whose types allow them to be exported
                // TODO (MRA) It's inefficient to keep iterating over every function every time
                // we want to select an export
                let mut exportable_funcs = Vec::new();
                for (f_idx, (t_idx, _)) in m.funcs.iter().enumerate() {
                    if m.valid_export_types.contains(t_idx) {
                        exportable_funcs.push(f_idx);
                    }
                }
                if exportable_funcs.len() > 0 {
                    let idx = u.choose(exportable_funcs.as_slice())?;
                    Ok(Export::Func(*idx as u32))
                } else {
                    panic!("At least one export function should always be defined.");
                }
            });
        }

        if self.tables.len() > 0 {
            choices.push(|u, m| {
                let idx = u.int_in_range(0..=m.tables.len() - 1)?;
                Ok(Export::Table(idx as u32))
            });
        }

        if self.memories.len() > 0 {
            choices.push(|u, m| {
                let idx = u.int_in_range(0..=m.memories.len() - 1)?;
                Ok(Export::Memory(idx as u32))
            });
        }

        if self.globals.len() > 0 {
            choices.push(|u, m| {
                let idx = u.int_in_range(0..=m.globals.len() - 1)?;
                Ok(Export::Global(idx as u32))
            });
        }

        if choices.is_empty() {
            return Ok(());
        }

        arbitrary_loop(u, self.config.min_exports(), self.config.max_exports(), |u| {
            let name = unique_string()?;
            let f = u.choose(&choices)?;
            let export = f(u, self)?;
            self.exports.push((name, export));
            Ok(true)
        })
    }

    fn arbitrary_start(&mut self, u: &mut Unstructured) -> Result<()> {
        if !self.config.allow_start_export() {
            return Ok(());
        }

        let mut choices = Vec::with_capacity(self.funcs.len() as usize);

        for (func_idx, ty) in self.funcs() {
            if ty.params.is_empty() && ty.result.is_none() {
                choices.push(func_idx);
            }
        }

        if !choices.is_empty() && u.arbitrary().unwrap_or(false) {
            let f = *u.choose(&choices)?;
            self.start = Some(f);
        }

        Ok(())
    }

    fn arbitrary_elems(&mut self, u: &mut Unstructured) -> Result<()> {
        if self.size_of_biggest_table <= 0 {
            return Ok(());
        }
        let func_max = self.funcs.len() as u32;
        let table_tys = self.tables.iter().map(|t| t.elem_ty).collect::<Vec<_>>();

        let biggest_table = self.size_of_biggest_table as i32;
        // Create a helper closure to choose an arbitrary offset.
        let mut offset_global_choices = vec![];
        for (i, g) in self.globals.iter().enumerate() {
            if !g.mutable && g.val_type == ValType::I32 {
                offset_global_choices.push(i as u32);
            }
        }
        let allow_globalget = self.config.allow_globalget_in_elem_and_data_offsets();
        let arbitrary_offset = |u: &mut Unstructured| {
            Ok(if allow_globalget && !offset_global_choices.is_empty() && u.arbitrary()? {
                let g = u.choose(&offset_global_choices)?;
                Instruction::GlobalGet(*g)
            } else {
                Instruction::I32Const(u.int_in_range(0..=biggest_table)?)
            })
        };

        if table_tys.len() <= 0 {
            return Ok(());
        }

        arbitrary_loop(
            u,
            self.config.min_element_segments(),
            self.config.max_element_segments(),
            |u| {
                // Choose whether to generate a segment whose elements are initialized via
                // expressions, or one whose elements are initialized via function indices.
                let offset_instr = arbitrary_offset(u)?;
                let offset = match offset_instr {
                    Instruction::GlobalGet(_) => {
                        assert!(
                            self.config.allow_globalget_in_elem_and_data_offsets(),
                            "GlobalGet instruction in table offset currently not supported"
                        );
                        0
                    }
                    Instruction::I32Const(c) => c as u32,
                    Instruction::I64Const(c) => c as u32,
                    _ => panic!("Unsupported instruction in table offset"),
                };
                assert!(self.size_of_biggest_table >= offset);
                let max_table_size = self.size_of_biggest_table - offset;
                let min_elems = min(self.config.min_elements(), max_table_size as usize);
                let max_elems = min(self.config.max_elements(), max_table_size as usize);
                let kind = ElementKind::Active {
                    table:  None,
                    offset: offset_instr,
                };
                let ty = table_tys[0];
                let items = if ty == ValType::ExternRef {
                    let mut init = vec![];
                    arbitrary_loop(u, min_elems, max_elems, |u| {
                        init.push(
                            if ty == ValType::ExternRef || func_max == 0 || u.arbitrary()? {
                                None
                            } else {
                                Some(u.int_in_range(0..=func_max - 1)?)
                            },
                        );
                        Ok(true)
                    })?;
                    Elements::Expressions(init)
                } else {
                    let mut init = vec![];
                    if func_max > 0 {
                        arbitrary_loop(u, min_elems, max_elems, |u| {
                            let func_idx = u.int_in_range(0..=func_max - 1)?;
                            init.push(func_idx);
                            Ok(true)
                        })?;
                    }
                    Elements::Functions(init)
                };

                self.elems.push(ElementSegment {
                    kind,
                    ty,
                    items,
                });
                Ok(true)
            },
        )
    }

    fn arbitrary_code(&mut self, u: &mut Unstructured, allow_invalid: bool) -> Result<()> {
        self.code.reserve(self.num_defined_funcs);
        let mut allocs = CodeBuilderAllocations::new(self);
        for (_, ty) in self.funcs[self.funcs.len() - self.num_defined_funcs..].iter() {
            if !ty.auxiliary {
                let body = self.arbitrary_func_body(u, ty, &mut allocs, allow_invalid)?;
                self.code.push(body);
            }
        }
        // Creating (non-arbitrary) code for auxiliary functions
        for (_, callee_func_idx, required_type_idx) in self.auxiliary_funcs.iter() {
            let body = self.auxiliary_func_body(
                *callee_func_idx,
                self.ty(*required_type_idx),
                &mut allocs,
            )?;
            self.code.push(body);
        }
        Ok(())
    }

    fn auxiliary_func_body(
        &self,
        callee_func_idx: usize,
        required_type: &FuncType,
        allocs: &mut CodeBuilderAllocations<C>,
    ) -> Result<Code> {
        let locals = Vec::new();
        let mut builder = allocs.builder(required_type, &locals);
        let callee_type = &self.funcs[callee_func_idx].1;
        let body = builder.generate_auxiliary_fun_body(callee_func_idx, callee_type)?;
        let instructions = Instructions::Generated(body);
        Ok(Code {
            locals,
            instructions,
        })
    }

    fn arbitrary_func_body(
        &self,
        u: &mut Unstructured,
        ty: &FuncType,
        allocs: &mut CodeBuilderAllocations<C>,
        allow_invalid: bool,
    ) -> Result<Code> {
        let locals = self.arbitrary_locals(u)?;
        let builder = allocs.builder(ty, &locals);
        let instructions = if allow_invalid && u.arbitrary().unwrap_or(false) {
            Instructions::Arbitrary(arbitrary_vec_u8(u)?)
        } else {
            Instructions::Generated(builder.arbitrary(u, self)?)
        };

        Ok(Code {
            locals,
            instructions,
        })
    }

    fn arbitrary_locals(&self, u: &mut Unstructured) -> Result<Vec<ValType>> {
        let mut ret = Vec::new();
        arbitrary_loop(u, 0, 100, |u| {
            ret.push(self.arbitrary_valtype(u)?);
            Ok(true)
        })?;
        Ok(ret)
    }

    fn arbitrary_data(&mut self, u: &mut Unstructured) -> Result<()> {
        if self.size_of_biggest_memory <= 0 {
            return Ok(());
        }
        // With bulk-memory we can generate passive data, otherwise if there are
        // no memories we can't generate any data.
        let memories = self.memories.len() as u32;
        if memories == 0 {
            return Ok(());
        }

        let mut choices: Vec<Box<dyn Fn(&mut Unstructured) -> Result<Instruction>>> = vec![];
        let mem_limit = (self.size_of_biggest_memory * PAGE_SIZE) as i32;

        arbitrary_loop(u, self.config.min_data_segments(), self.config.max_data_segments(), |u| {
            if choices.is_empty() {
                choices.push(Box::new(move |u| {
                    Ok(Instruction::I32Const(u.int_in_range(0..=mem_limit)?))
                }));

                if self.config.allow_globalget_in_elem_and_data_offsets() {
                    for (i, g) in self.globals[..self.globals.len() - self.defined_globals.len()]
                        .iter()
                        .enumerate()
                    {
                        if !g.mutable && g.val_type == ValType::I32 {
                            choices.push(Box::new(move |_| Ok(Instruction::GlobalGet(i as u32))));
                        }
                    }
                }
            }

            // Passive data can only be generated if bulk memory is enabled.
            // Otherwise if there are no memories we *only* generate passive
            // data. Finally if all conditions are met we use an input byte to
            // determine if it should be passive or active.
            let f = u.choose(&choices)?;
            let offset = f(u)?;
            let offset_amount = match offset {
                Instruction::I32Const(n) => n,
                _ => 0,
            };
            let memory_index = u.int_in_range(0..=memories - 1)?;
            let kind = DataSegmentKind::Active {
                offset,
                memory_index,
            };
            let mut init = Vec::new();
            let data_elem_limit = mem_limit - offset_amount;
            let min_data_elems = min(self.config.min_data_elements(), data_elem_limit as usize);
            let max_data_elems = min(self.config.max_data_elements(), data_elem_limit as usize);
            arbitrary_loop(u, min_data_elems, max_data_elems, |u| {
                init.push(u.arbitrary()?);
                Ok(true)
            })?;
            self.data.push(DataSegment {
                kind,
                init,
            });
            Ok(true)
        })
    }
}

pub(crate) fn arbitrary_loop(
    u: &mut Unstructured,
    min: usize,
    max: usize,
    mut f: impl FnMut(&mut Unstructured) -> Result<bool>,
) -> Result<()> {
    assert!(max >= min);
    for _ in 0..min {
        if !f(u)? {
            break;
        }
    }
    for _ in 0..(max - min) {
        let keep_going = u.arbitrary().unwrap_or(false);
        if !keep_going {
            break;
        }

        if !f(u)? {
            break;
        }
    }

    Ok(())
}

static NAME_COUNTER: AtomicU8 = AtomicU8::new(0);

// TODO (MRA) We should also test ascii strings of different lengths but that's
// lower priority.
fn unique_string() -> Result<String> {
    let ctr = NAME_COUNTER.load(Ordering::SeqCst);
    let mut name = String::from(
        if ctr % 2 == 0 {
            "init_"
        } else {
            "receive."
        },
    );
    name.push_str(format!("{}", ctr).as_str());
    NAME_COUNTER.fetch_add(1, Ordering::SeqCst);
    Ok(name)
}

fn arbitrary_vec_u8(u: &mut Unstructured) -> Result<Vec<u8>> {
    let size = u.arbitrary_len::<u8>()?;
    Ok(u.get_bytes(size)?.to_vec())
}

#[derive(Clone, Debug)]
struct Defined {
    /// The section (index within `ConfiguredModule::initializers` that this
    /// type is defined.
    section: usize,
    /// Which element within the section definition this type corresponds
    /// to.
    nth: usize,
}
